pub mod callback_server;

use std::path::PathBuf;

use crate::{commands::discover, error::ZitadelCLIError};

use base64::{
    alphabet,
    engine::{self, general_purpose},
    Engine,
};
use callback_server::{init_callback_server, init_config_from_env};
use rand::{distributions::Alphanumeric, thread_rng, Rng};
use reqwest::Url;
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use tracing::{error, info};

pub(crate) struct AuthorizationFlowAppConfig {
    config_file_path: PathBuf,
    issuer: String,
    client_id: String,
    is_secure: bool,
    callback_server_address: String,
    scopes: String,
    code_verifier: String,
    code_challenge: String,
}

impl AuthorizationFlowAppConfig {
    pub fn redirect_uri(&self) -> String {
        match self.is_secure {
            true => format! {"https://{}/callback",self.callback_server_address},
            false => format! {"http://{}/callback",self.callback_server_address},
        }
    }
}

/// This is the main function of the module, each flow implemented has to have a login function
///  Generates the url to log in by using credentials, starts the callback server that writes the token to the file specified in the `CONFIG_FILE_PATH` environment variable
/// - `open_browser`: Whether to open the browser automatically
/// - Returns `Ok(())` if the login was successful
/// - Returns `Err(ZitadelCLIError::IO(error))` if the login was not successful
pub async fn login(open_browser: bool) -> Result<(), ZitadelCLIError> {
    let config: AuthorizationFlowAppConfig = init_config_from_env().unwrap();
    let discover_config =
        discover(&format! {"{}/.well-known/openid-configuration",&config.issuer}).await?;
    let url = generate_signin_url(
        &discover_config.authorization_endpoint,
        &config.client_id,
        &config.redirect_uri(),
        &config.scopes,
        &config.code_challenge,
    );
    if open_browser {
        match open::that(url.to_string()) {
            Ok(()) => {
                info! {"Sign in page successfully opened at {url}"};
            }
            Err(error) => {
                error! {"Failed to open the url: {error}, please open your browser and navigate to {url}"};
            }
        };
    } else {
        info! {"Open the following URL in your browser: {url}"};
    }
    match init_callback_server(config).await {
        Ok(server) => server.await.map_err(|error| error.into()),
        Err(error) => {
            error! {"Failed to start server: {error}"};
            Err(error.into())
        }
    }
}

#[derive(Debug, Deserialize, Serialize)]
pub struct CodeResponse {
    pub access_token: String,
    pub expires_in: u64,
    pub id_token: Option<String>,
    pub scope: Option<String>,
    pub refresh_token: Option<String>,
    pub token_type: String,
}

/// Exchanges the `code` returned by the authorize endpoint for an `access_token`
/// `token_endpoint` is the token endpoint of the OpenID Connect provider
/// `client_id` is the client id of the application
/// `code` is the code returned by the authorize endpoint
/// `redirect_uri` is the uri to redirect to after the sign in
/// `code_verifier` is the random string generated by `generate_code_verifier`
/// `code_challenge` is the code challenge generated from the `code_verifier`
/// Returns the `access_token` and other information
pub async fn exchange_code(
    token_endpoint: String,
    client_id: String,
    code: String,
    redirect_uri: String,
    code_verifier: String,
    code_challenge: String,
) -> Result<CodeResponse, ZitadelCLIError> {
    let url = Url::parse_with_params(
        &token_endpoint,
        &[
            ("code", code),
            ("grant_type", String::from("authorization_code")),
            ("redirect_uri", redirect_uri),
            ("client_id", client_id),
            ("code_verifier", code_verifier),
            ("code_challenge", code_challenge),
        ],
    )?;
    let response = reqwest::get(url).await?;
    match response.status() {
        reqwest::StatusCode::OK => {
            let parsed_response = response.json::<CodeResponse>().await?;
            Ok(parsed_response)
        }
        _ => {
            return Err(ZitadelCLIError::ReqwestResponse(response.text().await?));
        }
    }
}

/// Generates a random string of length between 43 and 128, used to generate the `code_challenge`
/// Returns the generated string
pub fn generate_code_verifier() -> String {
    let length = rand::thread_rng().gen_range(43..=128);
    thread_rng()
        .sample_iter(&Alphanumeric)
        .take(length)
        .map(char::from)
        .collect()
}

/// Generates the `code_challenge` from the `code_verifier`, in the case of the Zitadel CLI, it uses the `S256` method
/// to hash the `code_verifier`
/// - `code_verifier` is the random string generated by `generate_code_verifier`
pub fn generate_code_challenge(code_verifier: String) -> String {
    let mut hasher = Sha256::new();
    hasher.update(code_verifier);
    let result = hasher.finalize();
    const CUSTOM_ENGINE: engine::GeneralPurpose =
        engine::GeneralPurpose::new(&alphabet::URL_SAFE, general_purpose::NO_PAD);

    CUSTOM_ENGINE.encode(result)
}

/// Generates the URL to sign in using OpenID Connect
/// - `base_url` is the base url of the OpenID Connect provider
/// - `client_id` is the client id of the application
/// - `redirect_uri` is the uri to redirect to after the sign in
/// - `scope` is the scope of the request
/// - `code_challenge` is the code challenge generated from the `code_verifier`
/// Returns the generated URL
pub fn generate_signin_url(
    base_url: &str,
    client_id: &str,
    redirect_uri: &str,
    scope: &str,
    code_challenge: &str,
) -> Url {
    let mut url = Url::parse(&base_url).unwrap();
    url.query_pairs_mut()
        .append_pair("client_id", client_id)
        .append_pair("redirect_uri", redirect_uri)
        .append_pair("scope", scope)
        .append_pair("response_type", "code")
        .append_pair("code_challenge", code_challenge)
        .append_pair("code_challenge_method", "S256");
    url
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_generate_signin_url() {
        let url = generate_signin_url(
            "https://zitadel.com/oauth/v2/authorize",
            "client_id",
            "redirect_uri",
            "scope",
            "code_challenge",
        );
        assert_eq!(url.to_string(), "https://zitadel.com/oauth/v2/authorize?client_id=client_id&redirect_uri=redirect_uri&scope=scope&response_type=code&code_challenge=code_challenge&code_challenge_method=S256");
    }
}
